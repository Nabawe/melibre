+ Names
+ CODEX
+ Abstract
+ TidyBranch as a Class vs a Modified Map
+ About Ids
+ Children Storage and Arrangement




+ Multithread, Async
+ Class : Element
+ Arrays all the Way
+ Iterator
+ array mutation, splice vs delete
+ Branches vs Nodes
+ Sparce Arrays
+ Modeling
+ Experiment Adding String Properties to Arrays
+ DocStrings


+ Names
    TidyTree, NearTree, InfinityCupboard, TaggedCupboard, chest of drawers, stack, accumulate, dresser?
+


+ CODEX
    - Mimir = Map indexed by Numeric keys containing ALL Branches.
    - Branch = The basic storage unit.
    - Root = A derivate of a Branch modeled to address it has no parent.
    - Position = Key of the Layout prop of a Branch representing where it currently is in its parent relative to its siblings on a specific moment.
    - Coordinate = The relative current position of a Branch.
+


+ Abstract
    Explicar origen, problema ( parsing FVE Field Value Expressions linked by logic ), la motivacion, posibles utilidades, etc.

    Luego de testear los limites de los Maps, Arrays, Number.MAX_SAFE_INTEGER, etc vi q es mejor hacer algo bastante light y para aplicaciones más serias usar una base de datos para Graphs u otra estructura especializada ya q JavaScript base no esta armado para operar en casos complejos pero si se lo puede extender.

    Solo tener 50 ramas q cada una va 50 para abajo parece ya ser bastante...

    Counter Arguments :
        Q muchas veces termina siendo mas eficiente transcodear el formato de una querry en otro simplemente tratandola con string manipulation en vez d tener q descomponer la logica.
+


+ TidyBranch as a Class vs a Modified Map
    Modeling using a Class for now since it will let me do things more cleanly and it appears that Modifying an Object causes more overhead that bunching different aspects in a class ( unless I missunderstood something ).
+


+ About Ids
    - After testing numeric Ids were twice as fast compared to string keys. The reason string keys were tested was to compare performance vs large number Ids but the limits of Maps, Arrays, and specially the memory of the host are used up far before numeric keys reach Number.MAX_SAFE_INTEGER, how "heavy" the things stored on the Maps, Arrays, etc are further constrain the memory limits.

    - JS uses an internal representation for any number no matter the base so using Hexadecimal was pointless.

    - Since the max ammount of Branches equals the max ammount of elements Mimir can have and this ammount will always be smaller than the ammount of elements that all Branches could hold then using Mimir Ids inside each branch becomes more practical.
        Mimir = Map
        Branches = Map
            Therefore both things have the same limits but there is only 1 Mimir and an undefined ammount of Branches.
        All Branches have to be registered on Mimir.
        So no new Branches could be created if Mimir reaches its max ammount of elements.
+


+ Children Storage and Arrangement
    Children will be stored in an Map<number, c_TidyBranch> in other words a Map indexed by the Ids generated by the Tree which contains the pointer to the Branch stored in Mimir. This Id is the same as the one stored in Mimir.

    Then to represent the arrangement of the Branches, its order, a separate Array of Branch pointers is kept, that is c_TidyBranch[]. Again this contains the pointers and not the Ids, if an Id for a concrete position is needed it is simply obtained by doing .id .

    - Advantages of Maps over Arrays
        Luego de rever las ventajas pensar:
            - Si Children solo se preocupa por la operacion .has no serviria mas q sea un Set?
            - Se podra eliminar Children y solo usar Layout y IdToPos? Ya q se usan los Ids de Mimir en vez de internos Branch por Branch.
            - Si la limitante es la cantidad de Ids q Mimir pueda contener, transformar Mimir en algo q guarda las Branches por donde estan contenidas y su Id dentro de esa Branch, o sea una Branch otorga Id interno a cada child.
            - The reasons to use a single array to keep the children arrangement are, to eliminate the need of traversing each child to peform any operation on the order and to be able to "operate directly on the order" like in a math function.

    - About Destructive Modifications

    - insertionPos:
        There are 3 posibilities:
            · Stored on each Branch as a prop referencing where on its parent it was inserted.
                It has the problem of needing to traverse all children any modification in the layout prop.
            · Stored on a Map or Object on the Parent, idToPos, it would be the reverse of the layout prop but using Ids, i.e. Map<Id, Position>.
                This way when something is reordered or deleted only modifying or recreating the layout and idToPos collections would be enogth, removing the need to traverse anything.
            · Not stored anywhere and if the position of a specific id is needed then do a for of or a for entries to iterate over the values and get the id, or use one of the array methods.

        For now I will use the idToPos idea but asking an AI to put some numbers to the performance and memory costs could be good.
+




+ Multithread, Async
    ! One might need to Freeze and UnFreeze and object when traversing it if multithread, async behaviour is involved
+


+ Class : Element
    tal vez crear una clase Element q normalmente solo guarda el value y se convierte en un array al tener un child pero creo q es peor ya q siempre va a ser alguna estructura mas grande q una Array y va a consumir mas CPU time
+


+ Arrays all the Way
    Para guardar un dato se guardaría en [].value pero cada branch es simplemente una array vacía en su expresión mínima, de esta manera las relaciones : parent, sibling, children quedan actualizadas automáticamente y también recuerdan un orden

    Aún así crear la clase branch o node

    Por ahi sea mejor usar Maps o WeakMaps en vez de arrays, supuestamente estan optimizados para ser modificados continuamente, al menos la doc dice q los objetos no lo estan pero no dice de las arrays ( y ademas todo es deribado de Object en JS... ).
+


+ Iterator
    Define an iterator that iterates over the whole tree in an ordered way that allows it to "be read" and keep hierarchy and etc.
+


+ array mutation, splice vs delete
    splice and other methods are to be used when modding an array and NOT delete

    delete though could be used to delete the 0 index and create an SPARCEARRAY check MDN delete

    It seams I will need to create a custom method that creates a deep-copy then fixes the new references coz delete and such methods seam to leave blank slots.
+


+ Branches vs Nodes
    meditar si la conceptualizacion es a base d nodos o Branches

    Decirle a Guido un ejemplo de cosas para pensar es q puedo preguntarle a un Node q una Branch no pueda responder, por ejemplo como encontrar los silblings y ver q concepto funciona mejor para modelar ( explicar q es modelar, creacion de classes ) o si es necesario usar los 2 conceptos, q es lo q estoy evitando, para q todo sea bien lean.

    Un nodo pierde el weight entre conexiones al crear un nodo nuevo y en contraste una rama mantiene identidad y valor ( imaginar q a una rama gorda le sale una rama fina )

    Las ramas permiten visualizar los valores q guardan y en este caso buscan ser más permanentes.

    Los nodos probablemente pueden almacenar una diversidad mayor de información o sea más variedad de tipo de conceptos de información

    pensar sobre lo de distancia al centro y otras cosas reprecentables por el diametro del nodo, es una analogia, una visualizacion de una propiedad igual y seguro se podría hacer lo mismo con una branch. su ancho?
+


+ Sparce Arrays
    Revisar en MDN q es lo q pierden las array si definía custom props estoy casi seguro q está en la pag mdn arrays.

    const arr = [1, 2, , , 5]; // Create a sparse array
    ! Spreading into an Array
        const another = [...arr]; // "another" is [ 1, 2, undefined, undefined, 5 ]
        !!! Spreading into an Object uses property enumeration, not the array's iterator
            const objectSpread = { ...arr }; // { '0': 1, '1': 2, '4': 5 }

    But in others (most notably array iteration methods), empty slots are skipped.
        ! const hasFalsy = arr.some((k) => !k); // false

        * Property enumeration
            const keys = Object.keys(arr); // [ '0', '1', '4' ]
            for (const key in arr)
                console.log(key);

        * const mapped = arr.map((i) => i + 1); // [ 2, 3, <2 empty items>, 6 ]
        * arr.forEach((i) => console.log(i)); // 1 2 5
        * const filtered = arr.filter(() => true); // [ 1, 2, 5 ]

    Hacer mas prolijo y funcional el resumen? tal vez mejor skim y encontrar una solucion mas universal, pensar menos en esto, crear la clase y luego ver los problemas teniendo una base teorica general.

    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#sparse_arrays
        poorly writen just check the specific section

    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#array_methods_and_empty_slots
+


+ Modeling
    Otros métodos podrían ser:
    +Continue dónde crea una branch sibling
    +Spawn dónde crea una branch child
    +spawnUncle donde crea una branch sibling al parent

    Creo q es mejor q todos empiecen con spawn

    O sea son metodos q permiten el ir haciendo crecer el árbol de manera lógica e ir guardando valores.

    Otros métodos:
    Open,close,grow ... Branch q equivalen a ( ) newSibling

    openNewBranch, closeLastOpenedBranch
+


+ f_parseLogic
    ask claude about coping, remembering and modifying arrays, about shallow vs deep

    Recordar pos con array o una var q sea current.

    branch[lvl][twig] = [];
    branch[lvl][twig].insertionPos

    vs

    current
    insertionPos


    luego abajo:

    if lvl === 0 o_Tree.push( realChar )
    else currentParent.push( realChar)
    OR
    else branch[lvl][twig].push ( realChar)


    Luego arriba en )
    Retorna el puntero a la array q sea su padre

    currentBranch = [];
    growingBranches[lvl][twig] = currentBranch;
    currentBranch.insertionPos = posición en la array parent; (ver q se guarde en la array original y no en el puntero)
    currentTwig = twig;

    id o twig ya q puede haber más de un set de paréntesis por Branch.

    Ver si delete causa reindexacion
+


+ Experiment Adding String Properties to Arrays
    See what happens with different iteration methods, fors, etc.
+


+ DocStrings
    https://claude.ai/chat/e670ecbe-3a7c-47db-8369-f99f17fa62f7
+
